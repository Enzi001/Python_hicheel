#Big O 
# Алгоритмын үр дүнг хэмжих нэгж
# Жишээ: O(1), O(n), O(log n), O(n^2) гэх мэт.
# Big O нь алгоритмыг олох хамгийн оновчтой тэмдэглэгээ

# O(1) Тогтмол хугацаа 
# O(n) Алгоритмын гүйцэтгэл  Шугаман хугацаа
# O(log n) Binary search  Логарифмын хугацаа
# O(n**2) Квадрат хугацаа 

# jims = ["apple", "dwaf" "danpfpawnf[w]" "fioegnpengeg"]




# Алгоритмын Цаг Хугацааны Шинжилгээ (Time Complexity Analysis)

# Цаг хугацааны нийлэмжийн шинжилгээ нь алгоритмын гүйцэтгэлийг хэмжихэд тусалдаг бөгөөд алгоритмын ажиллагааг илүү үр ашигтай болгоход чиглэгдсэн. Энэ хэсэгт алгоритмын гурван төрлийн цаг хугацааны нийлэмжийн шинжилгээний талаар ярилцъя: хамгийн сайн тохиолдол (Best Case), хамгийн муу тохиолдол (Worst Case), дундаж тохиолдол (Average Case).

# 1. Цаг Хугацааны Нийлэмжийн Төрлүүд:
# Хамгийн Сайн Тохиолдол (Best Case):
# Алгоритм хамгийн бага хугацаанд гүйцэтгэгдэх нөхцөл. Энэ тохиолдолд гүйцэтгэлийн хугацаа хамгийн бага байна.
# Жишээ: Өгөгдлийн жагсаалтаас хайж байгаа элемент нь жагсаалтын хамгийн эхэнд байвал шугаман хайлт алгоритмын хувьд хамгийн сайн тохиолдол гэж тооцогдоно. Энэ нөхцөлд алгоритмын нийлэмж нь O(1) буюу тогтмол хугацаатай байна.
# Хамгийн Муу Тохиолдол (Worst Case):
# Алгоритм хамгийн их хугацаанд гүйцэтгэгдэх нөхцөл. Энэ тохиолдолд гүйцэтгэлийн хугацаа хамгийн их байна.
# Жишээ: Өгөгдлийн жагсаалтаас хайж байгаа элемент нь жагсаалтын хамгийн сүүлд эсвэл байхгүй байвал шугаман хайлт алгоритмын хувьд хамгийн муу тохиолдол гэж тооцогдоно. Энэ нөхцөлд алгоритмын нийлэмж нь O(n) буюу шугаман хугацаатай байна.
# Дундаж Тохиолдол (Average Case):
# Алгоритм дундаж нөхцөлд гүйцэтгэгдэх хугацаа. Энэ нь алгоритмын гүйцэтгэлийг нийт боломжит оролтын дундаж дээр үнэлнэ.
# Жишээ: Дундаж тохиолдолд шугаман хайлт хийхэд хайж байгаа элемент нь ихэвчлэн жагсаалтын хаа нэгтээ байрлана гэж үздэг. Иймээс алгоритмын дундаж нийлэмж нь O(n) байна.


# Orolt 3612
# Garalt 1 0 12

# Алхам 1 функц зарлана
# Алхам 2 гараас тоо авах
# Алхам 3 Цагийг олох Өгөгдсөн секундын 3600 д хуваагаад бүхэл хэсэг / ашиглана
# Алхам 4 Үлдэгдэл минутыг олно  Үлдсэн секундыг 60д хувааж бүхэл / хэсгийг авна
# Алхам 5 Үлдсэн секунд олох 

# def convert(seconds):
#     # Цагийг олох
#     hours = seconds // 3600
#     # минут олох
#     minutes = (seconds % 3600) // 60
#     # үлдсэн секундыг олох
#     remain_seconds = seconds % 60
#     print(hours, minutes, remain_seconds)


# seconds_input=int(input("Секундыг тоо оруулна уу: "))
# convert(seconds_input)

# Шугаман хугацааны нийлэмжтэй алгоритм

# def print(arr):
#     for element in arr:
#         print(element)

# Квадрат хугацааны нийлэмж


# def print(arr):
#     for i in range(len(arr)):
#         for j in range(len(arr)):
#             print(arr[i], arr[j])

# def find_max(arr):
#     max_val = arr[0]
#     for i in range(1, len(arr)):
#         if arr[i] > max_val:
#             max_val = arr[i]
#     return max_val

# O(n)

# def check_duplicates(arr):
#     for i in range(len(arr)):
#         for j in range(i + 1, len(arr)):
#             if arr[i] == arr[j]:
#                 return True
#     return False

# Big O Тэмдэглэгээний Төрлүүдийн Дэлгэрэнгүй Тайлбар ба График
# Big O тэмдэглэгээ нь алгоритмын гүйцэтгэлийн өсөлтийг оролтын хэмжээтэй харьцуулан илэрхийлэх арга юм. Энэ нь алгоритмын цаг хугацааны нийлэмжийн шинжилгээнд ашиглагддаг. Энд бид хамгийн түгээмэл Big O тэмдэглэгээнүүдийг болон тэдгээрийн алгоритмын гүйцэтгэлд хэрхэн нөлөөлөхийг тайлбарлая:

# 1. O(1) – Тогтмол хугацаа (Constant Time)
# Тайлбар: Алгоритмын гүйцэтгэл нь оролтын хэмжээнээс (n) үл хамааран үргэлж тогтмол хугацаанд гүйцэтгэгддэг. Өөрөөр хэлбэл, оролтын хэмжээ ямар ч байсан гүйцэтгэлийн хугацаа өөрчлөгддөггүй.

# def get_first(arr):
#     return arr[0]

# 2. O(n) – Шугаман хугацаа (Linear Time)
# Тайлбар: Алгоритмын гүйцэтгэл нь оролтын хэмжээ (n)-ээс шууд хамаардаг. Өөрөөр хэлбэл, оролтын хэмжээ 2 дахин ихсэхэд алгоритмын гүйцэтгэл 2 дахин ихсэх болно.

# def find_element(arr, elemnt)

# 3 . O(log n) – Логарифмын хугацаа (Logarithmic Time)
# Тайлбар: Алгоритм нь оролтын хэмжээг логарифмаар бууруулдаг тул гүйцэтгэлийн хугацаа нь логарифмаар өсдөг. Ихэвчлэн оролтын хэмжээний ихэнх хэсгийг хуваах үйлдэл хийх алгоритмуудад гарч ирнэ.

# 4. O(n^2) – Квадрат хугацаа (Quadratic Time)
# Тайлбар: Алгоритмын гүйцэтгэл нь оролтын хэмжээний квадратаар (n^2) нэмэгддэг. Энэ нь ихэвчлэн давхар давталт ашигладаг алгоритмуудтай холбоотой.

# def bubble_sort(arr):
#     n = len(arr)
#     for i in range(n):
#         for j in range(0, n-i-1):
#             if arr[j] > arr[j+1]:
#                 arr[j], arr[j+1] = arr[j+1], arr[j]


# Зураглал: Гүйцэтгэлийн Өсөлтийн График
# Графикийг ашиглан эдгээр нийлэмжийн өсөлтийг харуулж болно. Доорхи график нь n хэмжээний хувьд Big O нийлэмжийн өсөлтийн жишээг харуулж байна:
# O(1): Тогтмол шугам (тэгш хэвтээ шугам) – Оролтын хэмжээ өөрчлөгдөх үед гүйцэтгэлийн хугацаа өөрчлөгдөхгүй.
# O(n): Шугаман шугам – Оролтын хэмжээ ихсэхэд хугацаа түүнд пропорционалаар өснө.
# O(log n): Логарифмын муруй – Оролтын хэмжээ ихсэхэд хугацаа аажмаар өснө.
# O(n^2): Квадрат муруй – Оролтын хэмжээ ихсэхэд хугацаа хурдтайгаар өснө.
# Энэ график нь алгоритмын гүйцэтгэлийн ялгааг дүрслэн харуулж, гүйцэтгэлийн нийлэмжийн ялгааг ойлгоход тусална.
